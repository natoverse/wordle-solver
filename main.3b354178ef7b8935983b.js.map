{"version":3,"file":"main.3b354178ef7b8935983b.js","mappings":";;;;AAiCA;;;;;;;;;AASA;AAYA;AChDA;;;ACwBA;AAGA;;;AAGA;AAEA;;;ACtCA;;;;AC2CA;;AAGA;;;;;ACpCA;AACA;AAIA;AACA;;;;;ACoEA;;;;;AAOA","sources":["webpack://wordle-solver/./src/components/WordBoxes/WordBoxes.tsx","webpack://wordle-solver/./.yarn/__virtual__/@fluentui-react-virtual-a7bcf7d20e/0/cache/@fluentui-react-npm-8.67.2-d269e8286f-32104ea1ee.zip/node_modules/@fluentui/react/lib/components/DetailsList/DetailsList.types.js","webpack://wordle-solver/./src/components/WordDisplay/WordDisplay.tsx","webpack://wordle-solver/./.yarn/cache/d3-dsv-npm-3.0.1-5d88fb8a85-5fc0723647.zip/node_modules/d3-dsv/src/dsv.js","webpack://wordle-solver/./src/App/components/DayPicker.tsx","webpack://wordle-solver/./src/App/components/Header.tsx","webpack://wordle-solver/./src/App/App.tsx"],"sourcesContent":["import type { FC } from 'react'\nimport styled from 'styled-components'\n\nimport type { MarkedWord } from '../../types.js'\nimport { Mark } from '../../types.js'\nexport interface WordBoxesProps {\n\tword?: MarkedWord\n}\n\nconst empty = {\n\tword: '',\n\tletters: new Array(5).fill({ letter: '', mark: Mark.Unset })\n}\n\nexport const WordBoxes: FC<WordBoxesProps> = ({ word = empty }) => {\n\treturn (\n\t\t<Container>\n\t\t\t{word.letters.map((letter, index) => {\n\t\t\t\treturn (\n\t\t\t\t\t<Letter key={`${letter}-${index}`} mark={letter.mark}>\n\t\t\t\t\t\t{letter.letter}\n\t\t\t\t\t</Letter>\n\t\t\t\t)\n\t\t\t})}\n\t\t</Container>\n\t)\n}\n\nconst Container = styled.div`\n\tdisplay: flex;\n\tgap: 4px;\n`\n\nconst Letter = styled.div<{ mark: Mark }>`\n\twidth: 32px;\n\theight: 32px;\n\tline-height: 32px;\n\ttext-transform: uppercase;\n\tfont-weight: bold;\n\tfont-size: 1.2em;\n\ttext-align: center;\n\tvertical-align: middle;\n\tbackground: ${({ mark, theme }) => {\n\t\tswitch (mark) {\n\t\t\tcase Mark.Unset:\n\t\t\t\treturn theme.application().faint().hex()\n\t\t\tcase Mark.None:\n\t\t\t\treturn '#3a3a3c'\n\t\t\tcase Mark.Elsewhere:\n\t\t\t\treturn '#b59f3b'\n\t\t\tcase Mark.Confirmed:\n\t\t\t\treturn '#538d4e'\n\t\t}\n\t}};\n\tborder: 1px solid ${({ theme }) => theme.application().lowContrast().hex()};\n`\n","/**\n * Enum to describe how a particular column header behaves.\n * This is used to to specify the property `IColumn.columnActionsMode`.\n * If `IColumn.columnActionsMode` is undefined, it's equivalent to `ColumnActionsMode.clickable`.\n * {@docCategory DetailsList}\n */\nexport var ColumnActionsMode;\n(function (ColumnActionsMode) {\n    /** Renders the column header as disabled. */\n    ColumnActionsMode[ColumnActionsMode[\"disabled\"] = 0] = \"disabled\";\n    /** Renders the column header as clickable. Default value. */\n    ColumnActionsMode[ColumnActionsMode[\"clickable\"] = 1] = \"clickable\";\n    /** Renders the column header as clickable and displays the dropdown chevron. */\n    ColumnActionsMode[ColumnActionsMode[\"hasDropdown\"] = 2] = \"hasDropdown\";\n})(ColumnActionsMode || (ColumnActionsMode = {}));\n/**\n * {@docCategory DetailsList}\n */\nexport var ConstrainMode;\n(function (ConstrainMode) {\n    /** Lets the content grow which allows the page to manage scrolling. */\n    ConstrainMode[ConstrainMode[\"unconstrained\"] = 0] = \"unconstrained\";\n    /** Constrains the list to the given layout space. */\n    ConstrainMode[ConstrainMode[\"horizontalConstrained\"] = 1] = \"horizontalConstrained\";\n})(ConstrainMode || (ConstrainMode = {}));\n/**\n * Enum to describe where the column has been dropped, after starting the drag\n * {@docCategory DetailsList}\n */\nexport var ColumnDragEndLocation;\n(function (ColumnDragEndLocation) {\n    /** Drag ended outside of current list */\n    ColumnDragEndLocation[ColumnDragEndLocation[\"outside\"] = 0] = \"outside\";\n    /** Drag ended within current list */\n    ColumnDragEndLocation[ColumnDragEndLocation[\"surface\"] = 1] = \"surface\";\n    /** Drag ended on header */\n    ColumnDragEndLocation[ColumnDragEndLocation[\"header\"] = 2] = \"header\";\n})(ColumnDragEndLocation || (ColumnDragEndLocation = {}));\n/**\n * {@docCategory DetailsList}\n */\nexport var DetailsListLayoutMode;\n(function (DetailsListLayoutMode) {\n    /**\n     * Lets the user resize columns and makes not attempt to fit them.\n     */\n    DetailsListLayoutMode[DetailsListLayoutMode[\"fixedColumns\"] = 0] = \"fixedColumns\";\n    /**\n     * Manages which columns are visible, tries to size them according to their min/max rules and drops\n     * off columns that can't fit and have isCollapsible set.\n     */\n    DetailsListLayoutMode[DetailsListLayoutMode[\"justified\"] = 1] = \"justified\";\n})(DetailsListLayoutMode || (DetailsListLayoutMode = {}));\n/**\n * {@docCategory DetailsList}\n */\nexport var CheckboxVisibility;\n(function (CheckboxVisibility) {\n    /** Visible on hover. */\n    CheckboxVisibility[CheckboxVisibility[\"onHover\"] = 0] = \"onHover\";\n    /** Visible always. */\n    CheckboxVisibility[CheckboxVisibility[\"always\"] = 1] = \"always\";\n    /** Hide checkboxes. */\n    CheckboxVisibility[CheckboxVisibility[\"hidden\"] = 2] = \"hidden\";\n})(CheckboxVisibility || (CheckboxVisibility = {}));\n//# sourceMappingURL=DetailsList.types.js.map","import type { FC } from 'react'\nimport styled from 'styled-components'\n\nimport { WordList } from '../WordList/WordList'\n\nexport interface WordDisplayProps {\n\ttitle: string\n\twords: string[]\n\tonWordClick?: (word: string) => void\n}\nexport const WordDisplay: FC<WordDisplayProps> = ({\n\ttitle,\n\twords,\n\tonWordClick,\n}) => {\n\treturn (\n\t\t<Container>\n\t\t\t<Header>\n\t\t\t\t{title} ({words?.length})\n\t\t\t</Header>\n\t\t\t<List>\n\t\t\t\t<WordList words={words} onClick={onWordClick} />\n\t\t\t</List>\n\t\t</Container>\n\t)\n}\n\nconst Container = styled.div`\n\theight: 600px;\n\twidth: 200px;\n\tborder: 1px solid ${({ theme }) => theme.application().border().hex()};\n`\n\nconst Header = styled.div`\n\tmargin: 0;\n\tpadding: 4px;\n\tbackground: ${({ theme }) => theme.application().lowContrast().hex()};\n`\nconst List = styled.div`\n\toverflow-y: scroll;\n\theight: 94%;\n`\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows,\n    formatRow: formatRow,\n    formatValue: formatValue\n  };\n}\n","import { IconButton } from '@fluentui/react'\nimport { addDays, subDays } from 'date-fns'\nimport type { FC} from 'react';\nimport { useCallback } from 'react'\nimport styled from 'styled-components'\n\nexport interface DayPickerProps {\n\tcurrent: Date\n\tonChange?: (date: Date) => void\n}\n\nexport const DayPicker: FC<DayPickerProps> = ({ current, onChange }) => {\n\tconst handleDecrement = useCallback(() => {\n\t\tonChange?.(subDays(current, 1))\n\t}, [current, onChange])\n\n\tconst handleIncrement = useCallback(() => {\n\t\tonChange?.(addDays(current, 1))\n\t}, [current, onChange])\n\n\treturn (\n\t\t<Container>\n\t\t\t<Day>{current.toDateString()}</Day>\n\t\t\t<Buttons>\n\t\t\t\t<IconButton\n\t\t\t\t\ticonProps={{ iconName: 'Back' }}\n\t\t\t\t\tonClick={handleDecrement}\n\t\t\t\t/>\n\t\t\t\t<IconButton\n\t\t\t\t\ticonProps={{ iconName: 'Forward' }}\n\t\t\t\t\tonClick={handleIncrement}\n\t\t\t\t/>\n\t\t\t</Buttons>\n\t\t</Container>\n\t)\n}\n\nconst Container = styled.div`\n\tdisplay: flex;\n\tjustify-content: space-between;\n\talign-items: center;\n`\n\nconst Day = styled.div`\n\tflex: 1;\n`\nconst Buttons = styled.div``\n","import type { FC } from 'react'\nimport styled from 'styled-components'\n\nexport const Header: FC = () => <Container>Wordle Solver!</Container>\n\nconst Container = styled.h1`\nmargin: 0;\npadding: 10px;\n\twidth: 100%;\n\theight: 40px;\n\tcolor: ${({ theme }) => theme.application().highContrast().hex()};\n\ttext-shadow: ${({ theme }) => {\n\t\tconst shadow = theme.application().lowContrast().hex()\n\t\treturn `1px 0 0 ${shadow},0 1px 0 ${shadow},-1px 0 0 ${shadow},0 -1px 0 ${shadow};`\n\t}} \n\tbackground: ${({ theme }) => theme.application().accent().hex()};\n\tborder-bottom: 1px solid ${({ theme }) =>\n\t\ttheme.application().lowContrast().hex()};\n`\n","import { DefaultButton, Spinner, TextField } from '@fluentui/react'\nimport type { FC } from 'react'\nimport { memo, Suspense } from 'react'\nimport { RecoilRoot } from 'recoil'\nimport styled from 'styled-components'\n\nimport { WordBoxes } from '../components/WordBoxes/WordBoxes.js'\nimport { WordDisplay } from '../components/WordDisplay/WordDisplay.js'\nimport { useData, useInputs, useMarkedResults } from './App.hooks.js'\nimport { DayPicker } from './components/DayPicker.js'\nimport { Header } from './components/Header.js'\nimport { StyleContext } from './StyleContext.js'\n\nexport const App: FC = memo(function App() {\n\tconst { guesses, answers } = useData()\n\tconst {\n\t\tsolution,\n\t\tonSolutionChange,\n\t\tguess,\n\t\tonGuessChange,\n\t\tdate,\n\t\tonDateChange,\n\t} = useInputs(answers)\n\n\tconst { doTest, tries, remaining } = useMarkedResults(\n\t\tguess,\n\t\tsolution,\n\t\tguesses,\n\t)\n\n\treturn (\n\t\t<RecoilRoot>\n\t\t\t<Suspense fallback={<Spinner />}>\n\t\t\t\t<StyleContext>\n\t\t\t\t\t<Header />\n\n\t\t\t\t\t<Main>\n\t\t\t\t\t\t<Stacked>\n\t\t\t\t\t\t\t<Stack>\n\t\t\t\t\t\t\t\t<TextField\n\t\t\t\t\t\t\t\t\tlabel=\"Solution\"\n\t\t\t\t\t\t\t\t\tvalue={solution}\n\t\t\t\t\t\t\t\t\tonChange={(_e, val) => onSolutionChange(val)}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t<DayPicker current={date} onChange={onDateChange} />\n\t\t\t\t\t\t\t</Stack>\n\t\t\t\t\t\t\t<TextField\n\t\t\t\t\t\t\t\tlabel=\"Guess\"\n\t\t\t\t\t\t\t\tvalue={guess}\n\t\t\t\t\t\t\t\tonChange={(_e, val) => onGuessChange(val)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<DefaultButton onClick={doTest}>Check</DefaultButton>\n\t\t\t\t\t\t\t{tries.map((t, idx) => (\n\t\t\t\t\t\t\t\t<WordBoxes key={idx} word={t} />\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</Stacked>\n\t\t\t\t\t\t<WordDisplay\n\t\t\t\t\t\t\ttitle={'Possible solutions'}\n\t\t\t\t\t\t\twords={answers}\n\t\t\t\t\t\t\tonWordClick={onSolutionChange}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<WordDisplay\n\t\t\t\t\t\t\ttitle={'Valid guesses'}\n\t\t\t\t\t\t\twords={guesses}\n\t\t\t\t\t\t\tonWordClick={onGuessChange}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<WordDisplay\n\t\t\t\t\t\t\ttitle={'Remaining guesses'}\n\t\t\t\t\t\t\twords={remaining}\n\t\t\t\t\t\t\tonWordClick={onGuessChange}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Main>\n\t\t\t\t</StyleContext>\n\t\t\t</Suspense>\n\t\t</RecoilRoot>\n\t)\n})\n\nconst Main = styled.div`\n\tpadding: 20px;\n\tdisplay: flex;\n\tgap: 12px;\n`\n\nconst Stacked = styled.div`\n\tdisplay: flex;\n\tflex-direction: column;\n\tgap: 10px;\n\twidth: 200px;\n`\n\nconst Stack = styled.div``\n"],"names":[],"sourceRoot":""}